<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Seongnam Scenario — Dispatcher Dashboard</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
    .panel { padding:12px; border:1px solid #eee; border-radius:8px; margin:12px 0; }
    .cards { display:flex; gap:12px; flex-wrap:wrap; margin:8px 0; }
    .card { flex:1 0 140px; border:1px solid #eee; border-radius:10px; padding:10px; }
    .card .title { font-size:12px; color:#666; }
    .card .value { font-size:20px; font-weight:700; }
    #logBox { background:#fafafa; border:1px solid #eee; padding:8px; border-radius:6px; max-height:220px; overflow:auto; }
    .barWrap { margin:10px 0; width:360px; }
    .barRail { height:10px; background:#eee; border-radius:5px; overflow:hidden; }
    .bar { height:10px; width:0%; background:#7c3aed; transition:width .3s; }
    .muted { color:#666; font-size:12px; }
    canvas { max-width:100%; }
  </style>
    <script>
        const API_BASE = window.location.origin; // 자동으로 127.0.0.1:8000 잡음
    </script>
</head>
<body>
  <h1 style="margin:0 0 8px;">Dispatcher Controller</h1>
  <div class="muted">FastAPI 서버와 연동된 최소 대시보드 (명령 → 시뮬 → 진행률/분석/차트)</div>

  <!-- ========== [MINIMAL UI] ========== -->
  <div class="panel">
    <input id="cmdInput" type="text" placeholder="예: 시뮬 시작" style="width:240px;">
    <button id="btnSend">보내기</button>
    <button id="btnStart">시뮬레이션 시작</button>
    <span id="statusLine" class="muted" style="margin-left:10px;">status: -</span>
  </div>

  <!-- 진행률 바 + 숫자 카드 -->
  <div class="barWrap">
    <div class="barRail"><div id="bar" class="bar"></div></div>
    <div id="barText" class="muted" style="margin-top:6px;">0%</div>
  </div>

  <div class="cards">
    <div class="card">
      <div class="title">Assigned (last)</div>
      <div id="cardAssigned" class="value">-</div>
    </div>
    <div class="card">
      <div class="title">Unassigned (last)</div>
      <div id="cardUnassigned" class="value">-</div>
    </div>
    <div class="card">
      <div class="title">Match Rate % (last)</div>
      <div id="cardMatch" class="value">-</div>
    </div>
    <div class="card" style="flex:1 0 220px;">
      <div class="title">Distance (mean / p50 / p90)</div>
      <div id="cardDist" class="value" style="font-size:16px;">-</div>
    </div>
  </div>

  <!-- 로그 -->
  <pre id="logBox" class="panel" style="margin-top:8px;"></pre>

  <!-- 라인 차트 -->
  <div class="panel">
    <canvas id="matchChart" width="560" height="220"></canvas>
  </div>

  <!-- Chart.js (once) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- ========== [API WIRING SCRIPT] ========== -->
  <script>
    // ---- 0) 기본 설정 ----
    // const API_BASE = window.location.origin;
    let pollTimer = null;

    const $ = (sel) => document.querySelector(sel);
    const log = (msg) => {
      const box = $("#logBox");
      const time = new Date().toLocaleTimeString();
      box.textContent += `[${time}] ${msg}\n`;
      box.scrollTop = box.scrollHeight;
    };

    // ===== (Chart) state & helpers =====
    const tickHistory = [];      // x축 라벨
    const matchHistory = [];     // y축 값 (match %)
    let matchChart = null;

    function createMatchChart() {
      const ctx = document.getElementById("matchChart");
      if (!ctx) return;
      matchChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: tickHistory,
          datasets: [{ label: "Match Rate (%)", data: matchHistory }]
        },
        options: {
          responsive: true,
          animation: false,
          scales: { y: { beginAtZero: true, max: 100 } },
          plugins: { legend: { display: true } }
        }
      });
    }

    function pushAndRenderMatchPoint(tickLabel, matchPercent) {
      tickHistory.push(tickLabel);
      matchHistory.push(matchPercent);
      if (!matchChart) createMatchChart();
      else matchChart.update();
    }

    // ---- 1) /process-command ----
    async function processCommand(text) {
      const res = await fetch(`${API_BASE}/process-command`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text })
      });
      if (!res.ok) throw new Error(`/process-command failed: ${res.status}`);
      return await res.json();  // { intent_type, message }
    }

    // ---- 2) /start-simulation ----
    async function startSimulation(total_ticks=12, sleep_sec=0) {
      const res = await fetch(`${API_BASE}/start-simulation`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ total_ticks, sleep_sec })
      });
      if (!res.ok) throw new Error(`/start-simulation failed: ${res.status}`);
      return await res.json();
    }

    // ---- 3) /simulation-status ----
    async function fetchStatus() {
      const res = await fetch(`${API_BASE}/simulation-status`);
      if (!res.ok) throw new Error(`/simulation-status failed: ${res.status}`);
      return await res.json();  // {running, progress, message, tick, total_ticks}
    }

    // ---- 4) /analysis-latest ----
    async function fetchAnalysis() {
      const res = await fetch(`${API_BASE}/analysis-latest`);
      if (!res.ok) throw new Error(`/analysis-latest failed: ${res.status}`);
      return await res.json();  // { last, history_len }
    }

    // ---- 5) 폴링 루프 ----
    function startPolling(intervalMs=1000) {
      if (pollTimer) clearInterval(pollTimer);
      pollTimer = setInterval(async () => {
        try {
          const s = await fetchStatus();
          $("#statusLine").textContent = `status: ${s.progress}% ${s.message}`;

          // (progress bar)
          const bar = $("#bar");
          const barText = $("#barText");
          bar.style.width = `${s.progress}%`;
          barText.textContent = `${s.progress}%`;

          if (!s.running) {
            clearInterval(pollTimer);
            pollTimer = null;
            log(`완료! progress=100%`);
            const a = await fetchAnalysis();
            log(`분석(last): ${JSON.stringify(a.last)}`);

            // 숫자카드 채우기
            const last = a.last || {};
            $("#cardAssigned").textContent   = last.last_assigned ?? "-";
            $("#cardUnassigned").textContent = last.last_unassigned ?? "-";
            $("#cardMatch").textContent      = last.last_match_rate ?? "-";

            // 거리 통계(있으면)
            const dm = last.distance_mean, p50 = last.distance_p50, p90 = last.distance_p90;
            $("#cardDist").textContent = (dm!=null && p50!=null && p90!=null)
              ? `${Number(dm).toFixed(1)} / ${Number(p50).toFixed(1)} / ${Number(p90).toFixed(1)}`
              : "-";

            // 차트 포인트 추가
            const tickLabel = (typeof s.tick === "number") ? `t${s.tick}` : `t${tickHistory.length}`;
            pushAndRenderMatchPoint(tickLabel, Number(last.last_match_rate ?? 0));
          }
        } catch (e) {
          clearInterval(pollTimer);
          pollTimer = null;
          log(`상태 폴링 에러: ${e.message}`);
        }
      }, intervalMs);
    }

    // ---- 6) 버튼 이벤트 ----
    $("#btnSend").addEventListener("click", async () => {
      const text = $("#cmdInput").value || "시뮬 시작";
      try {
        const r = await processCommand(text);
        log(`/process-command → ${r.intent_type}: ${r.message}`);
        if (r.intent_type === "START_SIMULATION") {
          await startSimulation(12, 0);
          startPolling(1000);
        }
        if (r.intent_type === "STATUS_CHECK") {
          const s = await fetchStatus();
          $("#statusLine").textContent = `status: ${s.progress}% ${s.message}`;
        }
        if (r.intent_type === "ANALYZE") {
          const a = await fetchAnalysis();
          log(`분석(last): ${JSON.stringify(a.last)}`);
        }
      } catch (e) {
        log(`에러: ${e.message}`);
      }
    });

    $("#btnStart").addEventListener("click", async () => {
      try {
        await startSimulation(12, 0);
        log(`/start-simulation → started`);
        startPolling(1000);
      } catch (e) {
        log(`에러: ${e.message}`);
      }
    });
  </script>
</body>
</html>
